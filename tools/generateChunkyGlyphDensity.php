<?php
/**
 * Chunky Glyph Density Analyzer
 * 
 * This utility analyzes the Chunky font PNG file and sorts characters by pixel density.
 * It outputs a PHP array that can be used by ChunkyAsciiArtConverter for accurate
 * brightness-to-glyph mapping.
 */

// Ensure the script can be run from any directory
$fontPath = dirname(__DIR__) . '/CHUNKY/CHUNKY.png';

if (!file_exists($fontPath)) {
    die("Error: Chunky font PNG not found at $fontPath\n");
}

// Define the Chunky character set in original order
function getChunkyFontGlyphs(): array
{
    return preg_split('//u', <<<CHUNKY
☺☻♥♦♣♠•◘○◙♂♀♪♫☼
►◄↕‼¶§▬↨↑↓→←∟↔▲▼
 !"#$%&'()*+,-./
0123456789:;<=>?
@ABCDEFGHIJKLMNO
PQRSTUVWXYZ[\]^_
`abcdefghijklmno
pqrstuvwxyz{|}~⌂
ÇüéâäàåçêëèïîìÄÅ
ÉæÆôöòûùÿÖÜ¢£¥₧ƒ
áíóúñÑªº¿⌐¬½¼¡«»
░▒▓│┤╡╢╖╕╣║╗╝╜╛┐
└┴┬├─┼╞╟╚╔╩╦╠═╬╧
╨╤╥╙╘╒╓╫╪┘┌█▄▌▐▀
αßΓπΣσµτΦΘΩδ∞φε∩
≡±≥≤⌠⌡÷≈°∙·√ⁿ²■□
CHUNKY, -1, PREG_SPLIT_NO_EMPTY);
}

// Check if GD is installed
if (!extension_loaded('gd')) {
    die("Error: PHP GD extension is required but not installed.\n");
}

echo "Analyzing Chunky font PNG file for character density...\n";

// Load the image
$image = @imagecreatefrompng($fontPath);
if (!$image) {
    die("Error: Failed to load Chunky PNG image.\n");
}

// Get image dimensions
$imgWidth = imagesx($image);
$imgHeight = imagesy($image);

echo "Image dimensions: {$imgWidth}x{$imgHeight} pixels\n";

// Define cell dimensions (8x8 pixels per character)
$cellWidth = 8;
$cellHeight = 8;

// Calculate grid dimensions (16 columns, variable rows)
$gridCols = 16;
$gridRows = ceil($imgHeight / $cellHeight);

echo "Font grid: {$gridCols}x{$gridRows} characters\n";

// Get the list of characters in original order
$glyphs = getChunkyFontGlyphs();
$totalGlyphs = count($glyphs);

echo "Total glyphs found: {$totalGlyphs}\n";

// Calculate density for each character
$densityMap = [];

for ($row = 0; $row < $gridRows; $row++) {
    for ($col = 0; $col < $gridCols; $col++) {
        $index = $row * $gridCols + $col;
        
        // Skip if we've gone beyond the available glyphs
        if ($index >= $totalGlyphs) {
            continue;
        }
        
        $char = $glyphs[$index];
        
        // Calculate pixel coordinates for this cell
        $x = $col * $cellWidth;
        $y = $row * $cellHeight;
        
        // Count non-white pixels in the cell
        $pixelCount = 0;
        $totalPixels = $cellWidth * $cellHeight;
        
        for ($py = 0; $py < $cellHeight; $py++) {
            for ($px = 0; $px < $cellWidth; $px++) {
                // Check if we're within image bounds
                if ($x + $px < $imgWidth && $y + $py < $imgHeight) {
                    $rgb = imagecolorat($image, $x + $px, $y + $py);
                    $r = ($rgb >> 16) & 0xFF;
                    $g = ($rgb >> 8) & 0xFF;
                    $b = $rgb & 0xFF;
                    
                    // Consider a pixel "on" if it's not white (allowing for some noise)
                    if ($r < 240 || $g < 240 || $b < 240) {
                        $pixelCount++;
                    }
                }
            }
        }
        
        // Calculate density (percentage of "on" pixels)
        $density = $pixelCount / $totalPixels;
        
        // Store in density map
        $densityMap[] = [
            'char' => $char,
            'density' => $density,
            'index' => $index
        ];
    }
}

// Sort by density
usort($densityMap, function($a, $b) {
    return $a['density'] <=> $b['density'];
});

// Create the sorted array
$sortedGlyphs = array_column($densityMap, 'char');

// Output the results
echo "Characters sorted by density (lowest to highest):\n";

// Group characters for better readability
$groups = 10;
$groupSize = ceil(count($sortedGlyphs) / $groups);

echo "\nDensity groups:\n";
for ($i = 0; $i < $groups; $i++) {
    $start = $i * $groupSize;
    $groupGlyphs = array_slice($sortedGlyphs, $start, $groupSize);
    $groupText = implode('', $groupGlyphs);
    $min = $i / $groups;
    $max = min(1.0, ($i + 1) / $groups);
    printf("Group %d (%.2f-%.2f): %s\n", $i + 1, $min, $max, $groupText);
}

// Generate PHP code for inclusion in the converter
echo "\n// PHP code to include in ChunkyAsciiArtConverter.php:\n";
echo "private \$sortedChunkyGlyphs = [\n";
$output = '';
foreach ($sortedGlyphs as $glyph) {
    $output .= "    '" . addcslashes($glyph, "'\\") . "',\n";
}
echo $output;
echo "];\n";

// Free memory
imagedestroy($image);

// Create a PHP file with the sorted array
$outputFile = dirname(__DIR__) . '/app/chunky_density_sorted.php';
$phpCode = "<?php\n/**\n * Sorted Chunky font glyphs by pixel density (low to high)\n * Generated by generateChunkyGlyphDensity.php\n */\n\nreturn [\n$output];\n";

file_put_contents($outputFile, $phpCode);
echo "\nSorted glyph array saved to app/chunky_density_sorted.php\n";

// Output formatted for web usage
echo "\nFormatted for web usage:\n";
echo "<pre>\n";
for ($i = 0; $i < $groups; $i++) {
    $start = $i * $groupSize;
    $groupGlyphs = array_slice($sortedGlyphs, $start, $groupSize);
    $groupText = implode('', $groupGlyphs);
    $min = $i / $groups;
    $max = min(1.0, ($i + 1) / $groups);
    printf("Brightness %.2f-%.2f: %s\n", $min, $max, $groupText);
}
echo "</pre>\n"; 